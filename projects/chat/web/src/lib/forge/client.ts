// Auto-generated by FORGE compiler - DO NOT EDIT
// @forge/client

// Entity Types
export interface User {
  id: string;
  created_at: string;
  updated_at: string;
  email: string;
  password_hash: string;
  display_name: string;
  avatar_url: string;
  role: 'owner' | 'admin' | 'member';
}

export interface Workspace {
  id: string;
  created_at: string;
  updated_at: string;
  name: string;
  slug: string;
  description: string;
  owner?: User;
  owner_id: string;
  members?: User[];
  members_id: string;
}

export interface Channel {
  id: string;
  created_at: string;
  updated_at: string;
  name: string;
  slug: string;
  description: string;
  visibility: 'public' | 'private';
  is_default: boolean;
  archived: boolean;
  workspace?: Workspace;
  workspace_id: string;
  members?: User[];
  members_id: string;
  creator?: User;
  creator_id: string;
}

export interface Message {
  id: string;
  created_at: string;
  updated_at: string;
  content: string;
  edited: boolean;
  deleted: boolean;
  channel?: Channel;
  channel_id: string;
  author?: User;
  author_id: string;
}

export interface Thread {
  id: string;
  created_at: string;
  updated_at: string;
  content: string;
  edited: boolean;
  parent?: Message;
  parent_id: string;
  author?: User;
  author_id: string;
}

export interface Reaction {
  id: string;
  created_at: string;
  updated_at: string;
  emoji: string;
  message?: Message;
  message_id: string;
  user?: User;
  user_id: string;
}

// Action Input Types
export interface CreateWorkspaceInput {
  name: string;
  slug: string;
  description?: string;
}

export interface CreateChannelInput {
  workspace_id: string;
  name: string;
  slug: string;
  description?: string;
  visibility?: 'public' | 'private';
}

export interface JoinChannelInput {
  channel_id: string;
}

export interface LeaveChannelInput {
  channel_id: string;
}

export interface SendMessageInput {
  channel_id: string;
  content: string;
}

export interface EditMessageInput {
  message_id: string;
  content: string;
}

export interface DeleteMessageInput {
  message_id: string;
}

export interface ReplyToMessageInput {
  message_id: string;
  content: string;
}

export interface AddReactionInput {
  message_id: string;
  emoji: string;
}

export interface RemoveReactionInput {
  reaction_id: string;
}

// View Types
export interface WorkspaceListItem {
  id: string;
  name: string;
  slug: string;
}

export interface ChannelListItem {
  id: string;
  name: string;
  slug: string;
  visibility: 'public' | 'private';
  is_default: boolean;
}

export interface MessageFeedItem {
  id: string;
  content: string;
  edited: boolean;
  deleted: boolean;
  created_at: string;
  author_id: string;
  author_display_name: string;
  author_avatar_url: string;
  thread_count: number;
}

export interface ThreadListItem {
  id: string;
  content: string;
  edited: boolean;
  created_at: string;
  author_id: string;
  author_display_name: string;
  author_avatar_url?: string;
}

export interface ThreadConversation {
  parent_message_id: string;
  parent_content: string;
  parent_author_id: string;
  parent_author_name: string;
  parent_author_avatar?: string;
  parent_created_at: string;
  channel_id: string;
  channel_name: string;
  reply_count: number;
  latest_reply_at: string;
  latest_reply_content: string;
  latest_reply_author_name: string;
  latest_reply_author_avatar?: string;
}

// Message Codes
export const MessageCodes = {
  MESSAGE_DELETED: 'MESSAGE_DELETED',
  CANNOT_ARCHIVE_DEFAULT: 'CANNOT_ARCHIVE_DEFAULT',
  AUTH_INVALID: 'AUTH_INVALID',
  MESSAGE_SENT: 'MESSAGE_SENT',
} as const;

export type MessageCode = keyof typeof MessageCodes;

// Client Configuration
export interface ForgeClientConfig {
  url: string;
  token?: string;
  onError?: (error: ForgeError) => void;
  onAuthError?: () => void;
}

// Error Type
export interface ForgeError {
  status: 'error';
  messages: { code: MessageCode; message?: string }[];
}

// Success Response
export interface ForgeResponse<T> {
  status: 'ok';
  data: T;
}

// Auth Response
export interface AuthResponse {
  token: string;
  user: User;
}

// Subscription Options
export interface SubscriptionOptions<T> {
  onData: (data: T[]) => void;
  onError?: (error: ForgeError) => void;
  onEphemeral?: (data: unknown) => void; // For typing indicators, presence, etc.
}

// Internal subscription with unique ID
interface InternalSubscription {
  id: number;
  options: SubscriptionOptions<unknown>;
}

// Forge Client
export class ForgeClient {
  private config: ForgeClientConfig;
  private ws: WebSocket | null = null;
  // Support multiple subscribers per viewKey
  private subscriptions: Map<string, InternalSubscription[]> = new Map();
  private nextSubscriptionId = 1;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 20; // Increased for better resilience
  private wsConnecting = false;
  private pendingMessages: string[] = [];
  private reconnectTimer: ReturnType<typeof setTimeout> | null = null;

  constructor(config: ForgeClientConfig) {
    this.config = config;
  }

  setToken(token: string | undefined) {
    this.config.token = token;
    // Reconnect websocket with new token
    if (this.ws) {
      this.wsConnecting = false;
      this.ws.close();
      this.ws = null;
      if (token) {
        this.connectWebSocket();
      }
    }
  }

  private async request<T>(method: string, path: string, body?: unknown): Promise<T> {
    const response = await fetch(`${this.config.url}${path}`, {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...(this.config.token ? { 'Authorization': `Bearer ${this.config.token}` } : {}),
      },
      body: body ? JSON.stringify(body) : undefined,
    });

    if (response.status === 401) {
      if (this.config.onAuthError) {
        this.config.onAuthError();
      }
      throw { status: 'error', messages: [{ code: 'AUTH_INVALID' }] };
    }

    const data = await response.json();
    if (data.status === 'error') {
      if (this.config.onError) {
        this.config.onError(data);
      }
      throw data;
    }

    return data.data;
  }

  // Auth - using mock JWT with entity API
  auth = {
    register: async (input: { email: string; password: string; display_name: string }): Promise<AuthResponse> => {
      // Create user via entity API
      const user = await this.request<User>('POST', '/api/entities/User', {
        email: input.email,
        password_hash: input.password, // In real app, this would be hashed
        display_name: input.display_name,
        avatar_url: '',
        role: 'member',
      });
      // Generate mock JWT token
      const token = btoa(JSON.stringify({ sub: user.id }));
      return { token, user };
    },
    login: async (input: { email: string; password: string }): Promise<AuthResponse> => {
      // Try to find user by email - in demo mode just create if not exists
      try {
        const users = await this.request<User[]>('GET', '/api/entities/User');
        const user = users.find(u => u.email === input.email);
        if (user) {
          const token = btoa(JSON.stringify({ sub: user.id }));
          return { token, user };
        }
      } catch (e) {
        // Entity list failed, try creating user
      }
      // Create new user for demo
      return this.auth.register({
        email: input.email,
        password: input.password,
        display_name: input.email.split('@')[0]
      });
    },
    me: async (): Promise<User> => {
      if (!this.config.token) throw { status: 'error', messages: [{ code: 'AUTH_INVALID' }] };
      try {
        const payload = JSON.parse(atob(this.config.token));
        const user = await this.request<User>('GET', `/api/entities/User/${payload.sub}`);
        return user;
      } catch {
        throw { status: 'error', messages: [{ code: 'AUTH_INVALID' }] };
      }
    },
    logout: () => {
      this.config.token = undefined;
      this.wsConnecting = false;
      this.pendingMessages = [];
      if (this.ws) {
        this.ws.close();
        this.ws = null;
      }
    },
  };

  // Actions - using entity API for direct operations
  actions = {
    createWorkspace: async (input: CreateWorkspaceInput): Promise<Workspace> => {
      const userId = this.getUserIdFromToken();
      return this.request<Workspace>('POST', '/api/entities/Workspace', {
        name: input.name,
        slug: input.slug,
        description: input.description || '',
        owner_id: userId,
        members_id: userId,
      });
    },
    createChannel: async (input: CreateChannelInput): Promise<Channel> => {
      const userId = this.getUserIdFromToken();
      return this.request<Channel>('POST', '/api/entities/Channel', {
        workspace_id: input.workspace_id,
        name: input.name,
        slug: input.slug,
        description: input.description || '',
        visibility: input.visibility || 'public',
        is_default: false,
        archived: false,
        creator_id: userId,
        members_id: userId,
      });
    },
    joinChannel: (input: JoinChannelInput) =>
      this.request<void>('POST', '/api/actions/join_channel', input),
    leaveChannel: (input: LeaveChannelInput) =>
      this.request<void>('POST', '/api/actions/leave_channel', input),
    sendMessage: async (input: SendMessageInput): Promise<Message> => {
      const userId = this.getUserIdFromToken();
      return this.request<Message>('POST', '/api/entities/Message', {
        channel_id: input.channel_id,
        content: input.content,
        edited: false,
        deleted: false,
        author_id: userId,
      });
    },
    editMessage: (input: EditMessageInput) =>
      this.request<Message>('PUT', `/api/entities/Message/${input.message_id}`, {
        content: input.content,
        edited: true,
      }),
    deleteMessage: (input: DeleteMessageInput) =>
      this.request<void>('DELETE', `/api/entities/Message/${input.message_id}`),
    replyToMessage: async (input: ReplyToMessageInput): Promise<Thread> => {
      const userId = this.getUserIdFromToken();
      return this.request<Thread>('POST', '/api/entities/Thread', {
        parent_id: input.message_id,
        content: input.content,
        edited: false,
        author_id: userId,
      });
    },
    addReaction: async (input: AddReactionInput): Promise<Reaction> => {
      const userId = this.getUserIdFromToken();
      return this.request<Reaction>('POST', '/api/entities/Reaction', {
        message_id: input.message_id,
        emoji: input.emoji,
        user_id: userId,
      });
    },
    removeReaction: (input: RemoveReactionInput) =>
      this.request<void>('DELETE', `/api/entities/Reaction/${input.reaction_id}`),
  };

  private getUserIdFromToken(): string {
    if (!this.config.token) return '';
    try {
      const payload = JSON.parse(atob(this.config.token));
      return payload.sub || '';
    } catch {
      return '';
    }
  }

  // Views - using entity API to fetch lists
  views = {
    workspaceList: () => this.request<WorkspaceListItem[]>('GET', '/api/entities/Workspace'),
    channelList: async (workspaceId: string): Promise<ChannelListItem[]> => {
      const channels = await this.request<Channel[]>('GET', '/api/entities/Channel');
      return channels.filter(ch => ch.workspace_id === workspaceId);
    },
    messageFeed: async (channelId: string): Promise<MessageFeedItem[]> => {
      const messages = await this.request<Message[]>('GET', '/api/entities/Message');
      const users = await this.request<User[]>('GET', '/api/entities/User');
      const threads = await this.request<Thread[]>('GET', '/api/entities/Thread');
      const userMap = new Map(users.map(u => [u.id, u]));

      // Count threads per message
      const threadCounts = new Map<string, number>();
      threads.forEach(t => {
        const count = threadCounts.get(t.parent_id) || 0;
        threadCounts.set(t.parent_id, count + 1);
      });

      return messages
        .filter(m => m.channel_id === channelId && !m.deleted)
        .map(m => {
          const author = userMap.get(m.author_id);
          return {
            id: m.id,
            content: m.content,
            edited: m.edited,
            deleted: m.deleted,
            created_at: m.created_at,
            author_id: m.author_id,
            author_display_name: author?.display_name || 'Unknown',
            author_avatar_url: author?.avatar_url || '',
            thread_count: threadCounts.get(m.id) || 0,
          };
        })
        .sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());
    },
    threadList: async (messageId: string): Promise<ThreadListItem[]> => {
      const threads = await this.request<Thread[]>('GET', '/api/entities/Thread');
      const users = await this.request<User[]>('GET', '/api/entities/User');
      const userMap = new Map(users.map(u => [u.id, u]));

      return threads
        .filter(t => t.parent_id === messageId)
        .map(t => {
          const author = userMap.get(t.author_id);
          return {
            id: t.id,
            content: t.content,
            edited: t.edited,
            created_at: t.created_at,
            author_id: t.author_id,
            author_display_name: author?.display_name || 'Unknown',
            author_avatar_url: author?.avatar_url,
          };
        })
        .sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());
    },
    // All threads grouped by parent message (for Threads page)
    allThreads: async (): Promise<ThreadConversation[]> => {
      const [threads, messages, users, channels] = await Promise.all([
        this.request<Thread[]>('GET', '/api/entities/Thread'),
        this.request<Message[]>('GET', '/api/entities/Message'),
        this.request<User[]>('GET', '/api/entities/User'),
        this.request<Channel[]>('GET', '/api/entities/Channel'),
      ]);

      const userMap = new Map(users.map(u => [u.id, u]));
      const messageMap = new Map(messages.map(m => [m.id, m]));
      const channelMap = new Map(channels.map(c => [c.id, c]));

      // Group threads by parent message
      const threadsByParent = new Map<string, Thread[]>();
      threads.forEach(t => {
        const existing = threadsByParent.get(t.parent_id) || [];
        existing.push(t);
        threadsByParent.set(t.parent_id, existing);
      });

      // Build conversation list
      const conversations: ThreadConversation[] = [];
      threadsByParent.forEach((threadList, parentId) => {
        const parentMessage = messageMap.get(parentId);
        if (!parentMessage) return;

        const channel = channelMap.get(parentMessage.channel_id);
        const parentAuthor = userMap.get(parentMessage.author_id);

        // Get latest reply
        const sortedThreads = threadList.sort(
          (a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
        );
        const latestReply = sortedThreads[0];
        const latestAuthor = userMap.get(latestReply.author_id);

        conversations.push({
          parent_message_id: parentId,
          parent_content: parentMessage.content,
          parent_author_id: parentMessage.author_id,
          parent_author_name: parentAuthor?.display_name || 'Unknown',
          parent_author_avatar: parentAuthor?.avatar_url,
          parent_created_at: parentMessage.created_at,
          channel_id: parentMessage.channel_id,
          channel_name: channel?.name || 'Unknown',
          reply_count: threadList.length,
          latest_reply_at: latestReply.created_at,
          latest_reply_content: latestReply.content,
          latest_reply_author_name: latestAuthor?.display_name || 'Unknown',
          latest_reply_author_avatar: latestAuthor?.avatar_url,
        });
      });

      // Sort by latest reply
      return conversations.sort(
        (a, b) => new Date(b.latest_reply_at).getTime() - new Date(a.latest_reply_at).getTime()
      );
    },
  };

  // WebSocket connection
  private connectWebSocket() {
    if (!this.config.token) {
      console.log('[WS] No token, skipping connection');
      return;
    }
    if (this.wsConnecting) {
      console.log('[WS] Already connecting, skipping');
      return;
    }
    if (this.ws?.readyState === WebSocket.OPEN) {
      console.log('[WS] Already connected');
      return;
    }

    this.wsConnecting = true;
    const wsUrl = this.config.url.replace('http', 'ws') + '/ws';
    console.log('[WS] Connecting to', wsUrl);
    const ws = new WebSocket(wsUrl);
    this.ws = ws;

    ws.onopen = () => {
      console.log('[WS] Connected!');
      this.wsConnecting = false;
      this.reconnectAttempts = 0;

      // Resubscribe to all views
      for (const [viewKey] of this.subscriptions) {
        console.log('[WS] Subscribing to', viewKey);
        ws.send(JSON.stringify({ type: 'subscribe', view: viewKey }));
      }

      // Send any pending messages
      while (this.pendingMessages.length > 0) {
        const msg = this.pendingMessages.shift();
        if (msg) {
          console.log('[WS] Sending pending message', msg);
          ws.send(msg);
        }
      }
    };

    ws.onmessage = (event) => {
      console.log('[WS] Received:', event.data);
      try {
        const msg = JSON.parse(event.data);
        if (msg.type === 'data') {
          const subs = this.subscriptions.get(msg.view);
          console.log('[WS] Data for view', msg.view, 'subscribers:', subs?.length || 0);
          if (subs) {
            const payload = msg.data || msg.items;
            // Notify all subscribers
            for (const sub of subs) {
              sub.options.onData(payload);
            }
          }
        } else if (msg.type === 'ephemeral') {
          // Handle ephemeral messages (typing, presence, etc.)
          const subs = this.subscriptions.get(msg.view);
          if (subs) {
            for (const sub of subs) {
              sub.options.onEphemeral?.(msg.data);
            }
          }
        } else if (msg.type === 'ack') {
          console.log('[WS] Ack:', msg.view, msg.data);
        } else if (msg.type === 'error') {
          console.log('[WS] Error:', msg.error);
          const subs = this.subscriptions.get(msg.view);
          if (subs) {
            for (const sub of subs) {
              sub.options.onError?.(msg);
            }
          }
        }
      } catch (e) {
        console.warn('[WS] Failed to parse message:', e);
      }
    };

    ws.onclose = (event) => {
      console.log('[WS] Closed:', event.code, event.reason);
      this.wsConnecting = false;
      this.ws = null;

      // Clear any existing reconnect timer
      if (this.reconnectTimer) {
        clearTimeout(this.reconnectTimer);
        this.reconnectTimer = null;
      }

      // Exponential backoff with max of 30 seconds
      if (this.reconnectAttempts < this.maxReconnectAttempts && this.subscriptions.size > 0) {
        this.reconnectAttempts++;
        const delay = Math.min(1000 * Math.pow(1.5, this.reconnectAttempts - 1), 30000);
        console.log('[WS] Reconnecting in', Math.round(delay / 1000), 'seconds (attempt', this.reconnectAttempts + ')');
        this.reconnectTimer = setTimeout(() => {
          this.reconnectTimer = null;
          this.connectWebSocket();
        }, delay);
      } else if (this.subscriptions.size === 0) {
        console.log('[WS] No subscriptions, not reconnecting');
      } else {
        console.log('[WS] Max reconnect attempts reached');
      }
    };

    ws.onerror = (error) => {
      console.warn('[WS] Error:', error);
      this.wsConnecting = false;
    };
  }

  // Subscriptions - supports multiple subscribers per viewKey
  subscribe<T>(viewKey: string, options: SubscriptionOptions<T>): () => void {
    const subscriptionId = this.nextSubscriptionId++;
    console.log('[WS] subscribe() called for', viewKey, 'id:', subscriptionId);

    // Add to the list of subscribers for this view
    const existing = this.subscriptions.get(viewKey) || [];
    const isFirstSubscriber = existing.length === 0;
    existing.push({ id: subscriptionId, options: options as SubscriptionOptions<unknown> });
    this.subscriptions.set(viewKey, existing);

    // Only send subscribe message to server for first subscriber
    if (isFirstSubscriber) {
      if (this.ws?.readyState === WebSocket.OPEN) {
        console.log('[WS] Already open, sending subscribe');
        this.ws.send(JSON.stringify({ type: 'subscribe', view: viewKey }));
      } else if (this.wsConnecting) {
        console.log('[WS] Connecting, queueing subscribe');
        this.pendingMessages.push(JSON.stringify({ type: 'subscribe', view: viewKey }));
      } else {
        console.log('[WS] Not connected, starting connection');
        // Reset reconnect attempts when new subscription is added
        this.reconnectAttempts = 0;
        this.connectWebSocket();
      }
    }

    return () => {
      console.log('[WS] Unsubscribing id:', subscriptionId, 'from', viewKey);
      const subs = this.subscriptions.get(viewKey);
      if (subs) {
        const filtered = subs.filter(s => s.id !== subscriptionId);
        if (filtered.length === 0) {
          // Last subscriber removed, unsubscribe from server
          this.subscriptions.delete(viewKey);
          if (this.ws?.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({ type: 'unsubscribe', view: viewKey }));
          }
        } else {
          this.subscriptions.set(viewKey, filtered);
        }
      }
    };
  }

  // Broadcast ephemeral data to view subscribers (typing, presence, etc.)
  broadcast(viewKey: string, data: unknown): void {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({ type: 'broadcast', view: viewKey, data }));
    }
  }

  // Force reconnect WebSocket (useful for debugging)
  reconnect(): void {
    console.log('[WS] Manual reconnect requested');
    this.reconnectAttempts = 0;
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
    if (this.ws) {
      this.ws.close();
    } else {
      this.connectWebSocket();
    }
  }

  // Get WebSocket connection status
  getConnectionStatus(): { connected: boolean; connecting: boolean; subscriptions: string[] } {
    return {
      connected: this.ws?.readyState === WebSocket.OPEN,
      connecting: this.wsConnecting,
      subscriptions: Array.from(this.subscriptions.keys()),
    };
  }
}

// Create default client
let defaultClient: ForgeClient | null = null;

export function createForgeClient(config: ForgeClientConfig): ForgeClient {
  defaultClient = new ForgeClient(config);
  return defaultClient;
}

export function getForgeClient(): ForgeClient {
  if (!defaultClient) {
    throw new Error('ForgeClient not initialized. Call createForgeClient first.');
  }
  return defaultClient;
}

