import { DocsLayout } from "@/components/docs/DocsLayout";
import { CodeBlock } from "@/components/docs/CodeBlock";

export default function MigrationsDocs() {
  return (
    <DocsLayout>
      <h1 className="text-4xl font-bold mb-6">Migrations</h1>

      <p className="text-xl text-muted-foreground mb-8">
        FORGE generates migrations automatically from your spec. You change the spec;
        the compiler figures out the SQL.
      </p>

      <h2 className="text-2xl font-bold mb-4">How It Works</h2>

      <p className="text-muted-foreground mb-4">
        When you run <code className="text-forge-400">forge build</code>, the compiler:
      </p>

      <ol className="space-y-2 text-muted-foreground mb-8">
        <li>1. Compares your current spec to the previous build</li>
        <li>2. Detects schema changes (new fields, changed types, removed entities)</li>
        <li>3. Generates migration SQL with proper ordering</li>
        <li>4. Stores migrations in <code className="text-forge-400">.forge/migrations/</code></li>
      </ol>

      <CodeBlock
        language="bash"
        code={`$ forge build
Building spec...
Detected schema changes:
  + Added field 'priority' to Ticket
  + Added entity 'Comment'
  ~ Changed type of 'description' from string(100) to text
Generated migration: 003_add_priority_and_comments.sql`}
      />

      <h2 className="text-2xl font-bold mt-8 mb-4">Applying Migrations</h2>

      <CodeBlock
        language="bash"
        code={`# Apply all pending migrations
forge migrate

# Show migration status
forge migrate --status

# Dry run (show SQL without applying)
forge migrate --dry-run

# Output
$ forge migrate --status
Applied migrations:
  ✓ 001_initial.sql (applied 2024-01-10)
  ✓ 002_add_users.sql (applied 2024-01-12)

Pending migrations:
  ○ 003_add_priority_and_comments.sql`}
      />

      <h2 className="text-2xl font-bold mt-8 mb-4">Generated SQL</h2>

      <p className="text-muted-foreground mb-4">
        Migrations are standard SQL files:
      </p>

      <CodeBlock
        filename=".forge/migrations/003_add_priority_and_comments.sql"
        language="sql"
        code={`-- Generated by FORGE compiler
-- Source: spec changes from 002 to 003

BEGIN;

-- Add priority field to tickets
ALTER TABLE tickets
ADD COLUMN priority ticket_priority NOT NULL DEFAULT 'medium';

-- Create comments table
CREATE TABLE comments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ticket_id UUID NOT NULL REFERENCES tickets(id),
  author_id UUID NOT NULL REFERENCES users(id)
);

CREATE INDEX idx_comments_ticket_id ON comments(ticket_id);
CREATE INDEX idx_comments_author_id ON comments(author_id);

-- Enable RLS
ALTER TABLE comments ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
CREATE POLICY comment_read ON comments
FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM tickets t
    JOIN org_members om ON om.org_id = t.org_id
    WHERE t.id = comments.ticket_id
    AND om.user_id = current_setting('app.user_id')::uuid
  )
);

COMMIT;`}
      />

      <h2 className="text-2xl font-bold mt-8 mb-4">Data Migrations</h2>

      <p className="text-muted-foreground mb-4">
        For changes that require data transformation, use the <code className="text-forge-400">migrate</code> block:
      </p>

      <CodeBlock
        code={`migrate Subscription.v2 {
  from: plan enum(free, pro)
  to: tier enum(free, starter, pro, enterprise)

  map:
    free -> free
    pro  -> starter
}`}
      />

      <p className="text-muted-foreground mt-4 mb-4">
        This generates:
      </p>

      <CodeBlock
        filename="Generated migration"
        language="sql"
        code={`-- Rename column and transform values
ALTER TABLE subscriptions
  ADD COLUMN tier subscription_tier;

UPDATE subscriptions SET tier = CASE
  WHEN plan = 'free' THEN 'free'::subscription_tier
  WHEN plan = 'pro' THEN 'starter'::subscription_tier
END;

ALTER TABLE subscriptions
  DROP COLUMN plan,
  ALTER COLUMN tier SET NOT NULL;`}
      />

      <h2 className="text-2xl font-bold mt-8 mb-4">Complex Migrations</h2>

      <p className="text-muted-foreground mb-4">
        For more complex data transformations:
      </p>

      <CodeBlock
        code={`migrate split_name {
  # Split 'name' into 'first_name' and 'last_name'
  from: User.name string
  to: {
    User.first_name string
    User.last_name string
  }

  transform: |
    first_name = split(name, ' ')[0]
    last_name = split(name, ' ')[1] ?? ''
}`}
      />

      <h2 className="text-2xl font-bold mt-8 mb-4">Rollback</h2>

      <p className="text-muted-foreground mb-4">
        Each migration has an automatic rollback:
      </p>

      <CodeBlock
        language="bash"
        code={`# Rollback the last migration
forge migrate --rollback

# Rollback to a specific version
forge migrate --rollback-to 002

# Show rollback SQL without applying
forge migrate --rollback --dry-run`}
      />

      <div className="bg-amber-500/10 border border-amber-500/30 rounded-xl p-6 mb-8">
        <h4 className="font-semibold text-amber-400 mb-2">Destructive Changes</h4>
        <p className="text-sm text-muted-foreground">
          Some operations (dropping columns, removing entities) require explicit confirmation:
        </p>
        <CodeBlock
          className="mt-4"
          language="bash"
          code={`$ forge migrate
Warning: This migration will:
  - Drop column 'legacy_field' from users (2,847 rows affected)
  - Delete table 'old_logs' (15,432 rows)

Run with --allow-destructive to proceed.`}
        />
      </div>

      <h2 className="text-2xl font-bold mb-4">Dev Mode Migrations</h2>

      <p className="text-muted-foreground mb-4">
        In development mode, migrations apply automatically on file change:
      </p>

      <CodeBlock
        language="bash"
        code={`$ forge dev
...
File changed: spec/app.forge
Rebuilding...
Migration 004_add_tags.sql generated
Applying migration...
Migration applied successfully.
Rebuild complete!`}
      />

      <h2 className="text-2xl font-bold mt-8 mb-4">Production Migrations</h2>

      <p className="text-muted-foreground mb-4">
        In production, migrations should be applied explicitly:
      </p>

      <CodeBlock
        language="bash"
        code={`# Build and check what migrations would run
forge build
forge migrate --dry-run

# Review the SQL, then apply
forge migrate

# Or as part of deployment
forge build && forge migrate && forge run`}
      />

      <h2 className="text-2xl font-bold mt-8 mb-4">Migration History</h2>

      <p className="text-muted-foreground mb-4">
        FORGE tracks applied migrations in a <code className="text-forge-400">_forge_migrations</code> table:
      </p>

      <CodeBlock
        language="sql"
        code={`SELECT * FROM _forge_migrations;

 id |           name                  |     applied_at
----+---------------------------------+---------------------
  1 | 001_initial.sql                 | 2024-01-10 09:00:00
  2 | 002_add_users.sql               | 2024-01-12 14:30:00
  3 | 003_add_priority_and_comments   | 2024-01-15 11:45:00`}
      />

      <div className="bg-emerald-500/10 border border-emerald-500/30 rounded-xl p-6 mt-8">
        <h4 className="font-semibold text-emerald-400 mb-2">No Hand-Written Migrations</h4>
        <p className="text-sm text-muted-foreground">
          Traditional ORMs require you to write migrations by hand—copy field definitions,
          remember foreign keys, handle indexes. FORGE generates all of this from your spec.
          Change the spec, get the migration. Your schema is always in sync with your spec.
        </p>
      </div>
    </DocsLayout>
  );
}
